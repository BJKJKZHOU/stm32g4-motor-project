##  位置观测器(非线性磁链)

```c
// See http://cas.ensmp.fr/~praly/Telechargement/Journaux/2010-IEEE_TPEL-Lee-Hong-Nam-Ortega-Praly-Astolfi.pdf
void foc_observer_update(float v_alpha, float v_beta, float i_alpha, float i_beta,
		float dt, observer_state *state, float *phase, motor_all_state_t *motor) {

	mc_configuration *conf_now = motor->m_conf;

	float R = conf_now->foc_motor_r;
	float L = conf_now->foc_motor_l;
	float lambda = conf_now->foc_motor_flux_linkage;

	// Saturation compensation
	switch(conf_now->foc_sat_comp_mode) {
	case SAT_COMP_LAMBDA:
		// Here we assume that the inductance drops by the same amount as the flux linkage. I have
		// no idea if this is a valid or even a reasonable assumption.
		if (conf_now->foc_observer_type >= FOC_OBSERVER_ORTEGA_LAMBDA_COMP ||
				conf_now->foc_observer_type >= FOC_OBSERVER_MXLEMMING_LAMBDA_COMP ||
				conf_now->foc_observer_type >= FOC_OBSERVER_MXV_LAMBDA_COMP ||
				conf_now->foc_observer_type >= FOC_OBSERVER_MXV_LAMBDA_COMP_LIN) {
			L = L * (state->lambda_est / lambda);
		}
		break;

	case SAT_COMP_FACTOR: {
		const float comp_fact = conf_now->foc_sat_comp * (motor->m_motor_state.i_abs_filter / conf_now->l_current_max);
		L -= L * comp_fact;
		lambda -= lambda * comp_fact;
	} break;

	case SAT_COMP_LAMBDA_AND_FACTOR: {
		if (conf_now->foc_observer_type >= FOC_OBSERVER_ORTEGA_LAMBDA_COMP ||
				conf_now->foc_observer_type >= FOC_OBSERVER_MXLEMMING_LAMBDA_COMP ||
				conf_now->foc_observer_type >= FOC_OBSERVER_MXV_LAMBDA_COMP ||
				conf_now->foc_observer_type >= FOC_OBSERVER_MXV_LAMBDA_COMP_LIN) {
			L = L * (state->lambda_est / lambda);
		}
		const float comp_fact = conf_now->foc_sat_comp * (motor->m_motor_state.i_abs_filter / conf_now->l_current_max);
		L -= L * comp_fact;
	} break;

	default:
		break;
	}

	// Temperature compensation
	if (conf_now->foc_temp_comp) {
		R = motor->m_res_temp_comp;
	}

	float ld_lq_diff = conf_now->foc_motor_ld_lq_diff;
	float id = motor->m_motor_state.id;
	float iq = motor->m_motor_state.iq;

	// Adjust inductance for saliency.
	if (fabsf(id) > 0.1 || fabsf(iq) > 0.1) {
		L = L - ld_lq_diff / 2.0 + ld_lq_diff * SQ(iq) / (SQ(id) + SQ(iq));
	}

	float L_ia = L * i_alpha;
	float L_ib = L * i_beta;
	const float R_ia = R * i_alpha;
	const float R_ib = R * i_beta;
	const float gamma_half = motor->m_gamma_now * 0.5;

	switch (conf_now->foc_observer_type) {
	case FOC_OBSERVER_ORTEGA_ORIGINAL: {
		float err = SQ(lambda) - (SQ(state->x1 - L_ia) + SQ(state->x2 - L_ib));

		// Forcing this term to stay negative helps convergence according to
		//
		// http://cas.ensmp.fr/Publications/Publications/Papers/ObserverPermanentMagnet.pdf
		// and
		// https://arxiv.org/pdf/1905.00833.pdf
		if (err > 0.0) {
			err = 0.0;
		}

		float x1_dot = v_alpha - R_ia + gamma_half * (state->x1 - L_ia) * err;
		float x2_dot = v_beta - R_ib + gamma_half * (state->x2 - L_ib) * err;

		state->x1 += x1_dot * dt;
		state->x2 += x2_dot * dt;
	} break;

	case FOC_OBSERVER_MXLEMMING:
	case FOC_OBSERVER_MXLEMMING_LAMBDA_COMP:
		// LICENCE NOTE:
		// This function deviates slightly from the BSD 3 clause licence.
		// The work here is entirely original to the MESC FOC project, and not based
		// on any appnotes, or borrowed from another project. This work is free to
		// use, as granted in BSD 3 clause, with the exception that this note must
		// be included in where this code is implemented/modified to use your
		// variable names, structures containing variables or other minor
		// rearrangements in place of the original names I have chosen, and credit
		// to David Molony as the original author must be noted.

		state->x1 += (v_alpha - R_ia) * dt - L * (i_alpha - state->i_alpha_last);
		state->x2 += (v_beta - R_ib) * dt - L * (i_beta - state->i_beta_last);

		if (conf_now->foc_observer_type == FOC_OBSERVER_MXLEMMING_LAMBDA_COMP) {
			float err = SQ(state->lambda_est) - (SQ(state->x1) + SQ(state->x2));
			state->lambda_est += 0.1 * gamma_half * state->lambda_est * -err * dt;
			utils_truncate_number(&(state->lambda_est), lambda * 0.3, lambda * 2.5);

			utils_truncate_number_abs(&(state->x1), state->lambda_est);
			utils_truncate_number_abs(&(state->x2), state->lambda_est);
		} else {
			utils_truncate_number_abs(&(state->x1), lambda);
			utils_truncate_number_abs(&(state->x2), lambda);
		}

		// Set these to 0 to allow using the same atan2-code as for Ortega
		L_ia = 0.0;
		L_ib = 0.0;
		break;

	case FOC_OBSERVER_ORTEGA_LAMBDA_COMP: {
		float err = SQ(state->lambda_est) - (SQ(state->x1 - L_ia) + SQ(state->x2 - L_ib));

		// FLux linkage observer. See:
		// https://cas.mines-paristech.fr/~praly/Telechargement/Conferences/2017_IFAC_Bernard-Praly.pdf
		state->lambda_est += 0.2 * gamma_half * state->lambda_est * -err * dt;

		// Clamp the observed flux linkage (not sure if this is needed)
		utils_truncate_number(&(state->lambda_est), lambda * 0.3, lambda * 2.5);

		if (err > 0.0) {
			err = 0.0;
		}

		float x1_dot = v_alpha - R_ia + gamma_half * (state->x1 - L_ia) * err;
		float x2_dot = v_beta - R_ib + gamma_half * (state->x2 - L_ib) * err;

		state->x1 += x1_dot * dt;
		state->x2 += x2_dot * dt;
	} break;

	case FOC_OBSERVER_MXV:
	case FOC_OBSERVER_MXV_LAMBDA_COMP:
	case FOC_OBSERVER_MXV_LAMBDA_COMP_LIN:
		state->x1 += (v_alpha - R_ia) * dt;
		state->x2 += (v_beta - R_ib) * dt;

		if (conf_now->foc_observer_type == FOC_OBSERVER_MXV_LAMBDA_COMP ||
				conf_now->foc_observer_type == FOC_OBSERVER_MXV_LAMBDA_COMP_LIN) {
			if (conf_now->foc_observer_type == FOC_OBSERVER_MXV_LAMBDA_COMP_LIN) {
				float mag = NORM2_f(state->x1 - L_ia, state->x2 - L_ib);
				UTILS_LP_FAST(state->lambda_est, mag, 0.1 * gamma_half * dt * SQ(state->lambda_est));
				utils_truncate_number(&(state->lambda_est), lambda * 0.3, lambda * 2.5);

				if (mag > state->lambda_est) {
					state->x1 = (state->x1 / mag) * state->lambda_est;
					state->x2 = (state->x2 / mag) * state->lambda_est;
				}
			} else if (conf_now->foc_observer_type == FOC_OBSERVER_MXV_LAMBDA_COMP) {
				float err = SQ(state->lambda_est) - (SQ(state->x1 - L_ia) + SQ(state->x2 - L_ib));
				state->lambda_est += 0.2 * gamma_half * state->lambda_est * -err * dt;
				utils_truncate_number(&(state->lambda_est), lambda * 0.3, lambda * 2.5);

				float mag = NORM2_f(state->x1 - L_ia, state->x2 - L_ib);
				if (mag > state->lambda_est) {
					state->x1 = (state->x1 / mag) * state->lambda_est;
					state->x2 = (state->x2 / mag) * state->lambda_est;
				}
			}
		} else {
			float mag = NORM2_f(state->x1 - L_ia, state->x2 - L_ib);
			if (mag > lambda) {
				state->x1 = (state->x1 / mag) * lambda;
				state->x2 = (state->x2 / mag) * lambda;
			}
		}
		break;

	default:
		break;
	}

	state->i_alpha_last = i_alpha;
	state->i_beta_last = i_beta;

	UTILS_NAN_ZERO(state->x1);
	UTILS_NAN_ZERO(state->x2);

	// Prevent the magnitude from getting too low, as that makes the angle very unstable.
	float mag = NORM2_f(state->x1, state->x2);
	if (mag < (lambda * 0.5)) {
		state->x1 *= 1.1;
		state->x2 *= 1.1;
	}

	if (phase) {
		*phase = utils_fast_atan2(state->x2 - L_ib, state->x1 - L_ia);
	}

	// Can we clamp the flux in dq with q flux = 0 and d flux is lambda
	// Then the state->x1 and state->x2 (which are the alpha and beta fluxes) are set as lambda*sin and lambda*cos
	// The d flux each time would have a residual after transform from ab to dq. This can be used as an input to the flux estimator
}

void foc_pll_run(float phase, float dt, float *phase_var,
					float *speed_var, mc_configuration *conf) {
	UTILS_NAN_ZERO(*phase_var);
	float delta_theta = phase - *phase_var;
	utils_norm_angle_rad(&delta_theta);
	UTILS_NAN_ZERO(*speed_var);
	*phase_var += (*speed_var + conf->foc_pll_kp * delta_theta) * dt;
	utils_norm_angle_rad((float*)phase_var);
	*speed_var += conf->foc_pll_ki * delta_theta * dt;
}
```












## 电流双采样双更新(或单更新)

**Counter-aligned mode** ，当**RCR=0**时，Counter TIMx_CNT = 0 和 ARR 时，都会触发 **Update event**，进入中断。  
可以在**0**和**ARR**中断触发ADC采样，一个PWM周期内采样两次。  
同一相的 O 时刻和 ARR 时刻下管不会都导通，
在ARR时刻采集本相电流，和另一相下管导通电流，在0时刻采集其他两相电流，其他相同理。  
如果MCU能计算得过来，可以双更新。

1.1 时序架构  
中心对齐PWM周期（50μs @ 20kHz）
```  
┌─────────────────────────────────────────────────────────┐
│                                                         │
0 ──▲──→ ARR ──▼──→ 0 ──▲──→ ARR ──▼──→ 0
    │         │         │         │
    ⚡        ⚡        ⚡        ⚡
  Update1  Update2  Update3  Update4
    │         │         │         │
    ●         ●         ●         ●
  采样1     采样2     采样3     采样4
    │         │         │         │
    ↓         ↓         ↓         ↓
  FOC1      FOC2      FOC3      FOC4
    │         │         │         │
    └─PWM1─┘  └─PWM2─┘  └─PWM3─┘
```

配置：RCR=0（双更新），TRGO=Update Event
频率：40kHz Update中断，40kHz FOC控制
1.2 电流重构策略（三电阻方案）
核心原理：在中心对齐模式下，0时刻和ARR时刻的下管导通状态不同，需要根据扇区选择采样相。
扇区划分（6个扇区）：
```       
         Sector 2
           ↑ β
           │
  Sector 3 │ Sector 1
    ───────┼───────→ α
  Sector 4 │ Sector 6
           │
         Sector 5
```

 
二、详细CubeMX配置方案
2.1 TIM1配置（关键修改）
打开CubeMX → Timers → TIM1：
Parameter Settings:
  Counter Settings:
    - Prescaler: 0
    - Counter Mode: Center Aligned Mode 1  ⚠️ 保持
    - Counter Period: 4249
    - Repetition Counter: 0  ⚠️ 改为0（双更新）
    - Auto-reload Preload: Enable
  
  Trigger Output (TRGO) Parameters:
    - Master Output Trigger (TRGO): Update Event  ⚠️ 改为Update Event
    - Master/Slave Mode: Enable
关键变化：
RepetitionCounter = 0：每次计数到0和ARR都产生Update事件
TRGO = Update Event：Update事件触发ADC
2.2 ADC1/ADC2配置
ADC1 Configuration:
  Mode:
    - Mode: Dual Mode → Injected simultaneous only
    - IN1 (PA0): Injected Channel Rank 1 (Ia)
    - IN2 (PA1): Injected Channel Rank 2 (Ib)
  
  Parameter Settings:
    ADC_Injected_Channel:
      - External Trigger: Timer 1 Trigger Out event  ⚠️ 改为TRGO
      - External Trigger Edge: Rising  ⚠️ 单边沿即可
      - Number of Conversions: 2
      - Rank 1: Channel 1, Sampling Time 6.5 Cycles
      - Rank 2: Channel 2, Sampling Time 6.5 Cycles
    
    ADC_Oversampling:
      - Oversampling Mode: Enabled
      - Ratio: 8x
      - Right Bit Shift: 3

ADC2 Configuration:
  （类似ADC1，采样Ic和Vbus）
  - Rank 1: Channel 3 (PA6) - Ic
  - Rank 2: Channel 4 (PA7) - Vbus

### 三、电流重构算法实现

#### 3.1 扇区与采样相对应关系（基于下管导通状态）

**核心原理**：在中心对齐PWM模式下，通过扇区判断三相PWM开关管的状态，选择下管导通的两相进行电流采样。

**下管导通判断规则**：
- **占空比越小，下管导通时间越长**
- 在PWM周期的0时刻和ARR时刻，下管导通状态不同
- 每个时刻选择下管导通的两相进行采样

**扇区定义与下管导通状态**（使用SVPWM_SectorBased的三线判断法）：

|------|---------|-----|----------|-----------|-----------------|
| **Sector 1** | 0°-60° | 3 | Vref1>0, Vref2>0, Vref3<0 | Tcm1>Tcm2>Tcm3 | 下管导通：Tcm3(最长), Tcm2(中等) |
| **Sector 2** | 60°-120° | 1 | Vref1>0, Vref2<0, Vref3<0 | Tcm2>Tcm1>Tcm3 | 下管导通：Tcm3(最长), Tcm1(中等) |
| **Sector 3** | 120°-180° | 5 | Vref1>0, Vref2<0, Vref3>0 | Tcm2>Tcm3>Tcm1 | 下管导通：Tcm1(最长), Tcm3(中等) |
| **Sector 4** | 180°-240° | 4 | Vref1<0, Vref2<0, Vref3>0 | Tcm3>Tcm2>Tcm1 | 下管导通：Tcm1(最长), Tcm2(中等) |
| **Sector 5** | 240°-300° | 6 | Vref1<0, Vref2>0, Vref3>0 | Tcm3>Tcm1>Tcm2 | 下管导通：Tcm2(最长), Tcm1(中等) |
| **Sector 6** | 300°-360° | 2 | Vref1<0, Vref2>0, Vref3<0 | Tcm1>Tcm3>Tcm2 | 下管导通：Tcm2(最长), Tcm3(中等) |

**修正后的采样策略表**（基于下管导通状态）：

扇区	角度范围	0时刻采样（下管导通）	ARR时刻采样（下管导通）	计算相	重构公式
1	    0°-60°      Ib, Ic	            Ia, Ib	                  Ic	    Ic = -(Ia+Ib)
2	    60°-120°	  Ia, Ic	            Ib, Ic	                  Ia	    Ia = -(Ib+Ic)
3	    120°-180°	  Ia, Ic	            Ib, Ic	                  Ia	    Ia = -(Ib+Ic)
4	    180°-240°	  Ia, Ib	            Ib, Ic	                  Ic	    Ic = -(Ia+Ib)
5	    240°-300°	  Ia, Ib	            Ia, Ic	                  Ib	    Ib = -(Ia+Ic)
6	    300°-360°	  Ib, Ic	            Ia, Ic	                  Ib	    Ib = -(Ia+Ic)

**原理说明**：
- **核心依据**：在中心对齐PWM模式下，上管和下管互补导通。**占空比越高，上管导通时间越长，下管导通时间越短**。采样时刻必须选择在下管导通时间足够长的位置，以确保电流稳定可测。

- **采样时刻固定**：在双更新模式（RCR=0）下，采样时刻固定在**0时刻（CNT=0）**和**ARR时刻（CNT=ARR）**这两个时间点。

- **下管导通判断**：在这两个固定时刻，通过扇区信息判断哪些相的下管处于导通状态：
  - **0时刻**：选择下管导通的两相进行采样
  - **ARR时刻**：选择下管导通的两相进行采样
  - 每个时刻都采样两相，第三相通过计算得到

- **扇区与导通状态对应**：
  - 使用SVPWM_SectorBased函数输出的扇区编号，结合PWM占空比关系确定下管导通状态
  - 每个扇区中，占空比最小的相下管导通时间最长，最适合采样

- **电流重构**：第三相通过基尔霍夫电流定律计算：Ia + Ib + Ic = 0

#### 3.2 代码实现框架

**Current.h 新增定义**：
```c
// 双更新模式支持
#define DUAL_UPDATE_MODE_ENABLE  1  // 1=启用双更新，0=单更新

#if DUAL_UPDATE_MODE_ENABLE
// 双更新模式下的采样数据结构
typedef struct {
    uint16_t adc_raw_at_zero[3];   // 0时刻采样：Ia, Ib, Ic
    uint16_t adc_raw_at_arr[3];    // ARR时刻采样：Ia, Ib, Ic
    uint8_t current_sector;         // 当前扇区 (1-6)
    uint8_t sample_phase;           // 采样阶段：0=0时刻，1=ARR时刻
} DualUpdateSample_t;

extern DualUpdateSample_t g_DualUpdateSample;

// 电流重构函数
void Current_Reconstruct(uint8_t sector,
                        uint16_t* adc_at_zero,
                        uint16_t* adc_at_arr,
                        float* ia, float* ib, float* ic);
#endif
```

**Current.c 实现电流重构**：
```c
#if DUAL_UPDATE_MODE_ENABLE

DualUpdateSample_t g_DualUpdateSample = {0};

/**
 * @brief  电流重构函数（三电阻双采样）
 * @param  sector: 当前扇区 (1-6)
 * @param  adc_at_zero: 0时刻ADC采样值 [Ia, Ib, Ic]
 * @param  adc_at_arr: ARR时刻ADC采样值 [Ia, Ib, Ic]
 * @param  ia, ib, ic: 输出重构后的三相电流 (A)
 */
void Current_Reconstruct(uint8_t sector,
                        uint16_t* adc_at_zero,
                        uint16_t* adc_at_arr,
                        float* ia, float* ib, float* ic)
{
    float i_temp[3] = {0};

    switch(sector) {
        case 1:  // Sector 1: 0时刻采Ib,Ic，ARR时刻采Ia,Ib
            Current_ADCToPhysical(adc_at_arr[0], &i_temp[0]);  // Ia from ARR
            Current_ADCToPhysical(adc_at_zero[1], &i_temp[1]); // Ib from 0
            i_temp[2] = -(i_temp[0] + i_temp[1]);              // Ic计算
            break;

        case 2:  // Sector 2: 0时刻采Ia,Ic，ARR时刻采Ib,Ic
            Current_ADCToPhysical(adc_at_zero[0], &i_temp[0]);  // Ia from 0
            Current_ADCToPhysical(adc_at_arr[1], &i_temp[1]);   // Ib from ARR
            i_temp[2] = -(i_temp[0] + i_temp[1]);              // Ic计算
            break;

        case 3:  // Sector 3: 0时刻采Ia,Ic，ARR时刻采Ib,Ic
            Current_ADCToPhysical(adc_at_zero[0], &i_temp[0]);  // Ia from 0
            Current_ADCToPhysical(adc_at_arr[1], &i_temp[1]);   // Ib from ARR
            i_temp[2] = -(i_temp[0] + i_temp[1]);              // Ic计算
            break;

        case 4:  // Sector 4: 0时刻采Ia,Ib，ARR时刻采Ib,Ic
            Current_ADCToPhysical(adc_at_zero[0], &i_temp[0]); // Ia from 0
            Current_ADCToPhysical(adc_at_arr[1], &i_temp[1]);  // Ib from ARR
            i_temp[2] = -(i_temp[0] + i_temp[1]);              // Ic计算
            break;

        case 5:  // Sector 5: 0时刻采Ia,Ib，ARR时刻采Ia,Ic
            Current_ADCToPhysical(adc_at_arr[0], &i_temp[0]);  // Ia from ARR
            Current_ADCToPhysical(adc_at_zero[1], &i_temp[1]); // Ib from 0
            i_temp[2] = -(i_temp[0] + i_temp[1]);              // Ic计算
            break;

        case 6:  // Sector 6: 0时刻采Ib,Ic，ARR时刻采Ia,Ic
            Current_ADCToPhysical(adc_at_arr[0], &i_temp[0]);  // Ia from ARR
            Current_ADCToPhysical(adc_at_zero[1], &i_temp[1]); // Ib from 0
            i_temp[2] = -(i_temp[0] + i_temp[1]);              // Ic计算
            break;

        default:
            // 扇区错误，返回0
            i_temp[0] = i_temp[1] = i_temp[2] = 0.0f;
            break;
    }

    *ia = i_temp[0];
    *ib = i_temp[1];
    *ic = i_temp[2];
}

/**
 * @brief  ADC注入转换完成回调（双更新模式）
 * @note   RCR=0时，每个PWM周期调用2次（0时刻和ARR时刻）
 */
void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc)
{
    if (hadc->Instance == ADC1)
    {
        // 读取ADC原始值
        uint16_t adc_ia = HAL_ADCEx_InjectedGetValue(&hadc1, ADC_INJECTED_RANK_1);
        uint16_t adc_ib = HAL_ADCEx_InjectedGetValue(&hadc1, ADC_INJECTED_RANK_2);
        uint16_t adc_ic = HAL_ADCEx_InjectedGetValue(&hadc2, ADC_INJECTED_RANK_1);

        if (g_DualUpdateSample.sample_phase == 0) {
            // 第一次采样（0时刻）
            g_DualUpdateSample.adc_raw_at_zero[0] = adc_ia;
            g_DualUpdateSample.adc_raw_at_zero[1] = adc_ib;
            g_DualUpdateSample.adc_raw_at_zero[2] = adc_ic;
            g_DualUpdateSample.sample_phase = 1;

            // 执行第一次FOC控制（使用上一周期的电流）
            // FOC_CurrentLoop();

        } else {
            // 第二次采样（ARR时刻）
            g_DualUpdateSample.adc_raw_at_arr[0] = adc_ia;
            g_DualUpdateSample.adc_raw_at_arr[1] = adc_ib;
            g_DualUpdateSample.adc_raw_at_arr[2] = adc_ic;
            g_DualUpdateSample.sample_phase = 0;

            // 电流重构
            float ia, ib, ic;
            Current_Reconstruct(g_DualUpdateSample.current_sector,
                              g_DualUpdateSample.adc_raw_at_zero,
                              g_DualUpdateSample.adc_raw_at_arr,
                              &ia, &ib, &ic);

            // 更新全局电流数据
            g_CurrentSample.current_abc[0] = ia;
            g_CurrentSample.current_abc[1] = ib;
            g_CurrentSample.current_abc[2] = ic;

            // 转换为标幺值
            Current_PhysicalToPU(ia, &g_CurrentSample.current_pu[0]);
            Current_PhysicalToPU(ib, &g_CurrentSample.current_pu[1]);
            Current_PhysicalToPU(ic, &g_CurrentSample.current_pu[2]);

            g_CurrentSample.sample_valid = 1;

            // 执行第二次FOC控制（使用重构后的电流）
            // FOC_CurrentLoop();
        }
    }
}

#endif // DUAL_UPDATE_MODE_ENABLE
```

#### 3.3 扇区更新机制

在SVPWM计算后，需要更新当前扇区信息：

```c
// 在FOC_Loop.c中，SVPWM计算后
void FOC_UpdateSector(float u_alpha, float u_beta)
{
    // 计算电压矢量角度
    float theta = atan2f(u_beta, u_alpha);

    // 归一化到[0, 2π]
    if (theta < 0) {
        theta += 2.0f * PI;
    }

    // 计算扇区 (1-6)
    uint8_t sector = (uint8_t)(theta / (PI / 3.0f)) + 1;
    if (sector > 6) sector = 6;

    // 更新到全局变量
    g_DualUpdateSample.current_sector = sector;
}
```

### 四、性能与注意事项

#### 4.1 计算负载评估

**40kHz中断频率下的时间预算**：
- 中断周期：25μs
- ADC采样+转换：~2μs
- 电流重构：~1μs
- Clarke+Park变换：~2μs
- PI控制器（Id, Iq）：~3μs
- 逆Park+SVPWM：~3μs
- **总计：~11μs**
- **剩余裕量：14μs（56%）**

**结论**：STM32G474 @ 170MHz 完全可以支持40kHz FOC控制。

#### 4.2 关键注意事项

1. **扇区同步**：
   - 必须在SVPWM计算后立即更新扇区信息
   - 扇区信息用于下一次电流重构
   - 避免扇区与采样数据不匹配

2. **中断优先级**：
   - ADC中断优先级设为最高（Priority 0）
   - 确保电流采样不被其他中断打断

3. **数据一致性**：
   - 使用`volatile`关键字保护共享变量
   - 或使用临界区保护电流数据读取

4. **调试建议**：
   - 初期可以只在ARR时刻执行FOC，0时刻仅采样
   - 验证电流重构算法正确性后再启用双更新
   - 使用示波器监测PWM和ADC触发时序

5. **降级策略**：
   - 极高占空比（>95%）时，电流重构可能不准确
   - 可以切换回单采样模式或使用估算值

#### 4.3 验证步骤

1. **硬件验证**：
   - 示波器CH1：TIM1_CH1 PWM输出
   - 示波器CH2：ADC触发信号（可通过GPIO输出标记）
   - 示波器CH3：中断执行时间（GPIO翻转）
   - 验证触发时序正确

2. **软件验证**：
   - 开环模式下，固定扇区，验证电流重构
   - 检查 Ia + Ib + Ic ≈ 0（误差<5%）
   - 对比单采样和双采样的电流波形

3. **性能验证**：
   - 测量中断执行时间（最大/平均/最小）
   - 确认CPU占用率 < 50%
   - 验证控制带宽提升效果

### 五、方案对比总结

| 特性 | 单采样单更新 (RCR=1) | 双采样双更新 (RCR=0) |
|------|---------------------|---------------------|
| **控制频率** | 20kHz | 40kHz |
| **中断频率** | 20kHz | 40kHz |
| **电流采样** | 1次/PWM周期 | 2次/PWM周期 |
| **电流重构** | 不需要 | 需要（根据扇区） |
| **CPU负载** | ~25% | ~45% |
| **控制带宽** | ~2kHz | ~4kHz |
| **实现复杂度** | 简单 | 中等 |
| **适用场景** | 通用应用 | 高性能伺服 |

**推荐选择**：
- 初期开发：使用单采样单更新（RCR=1）
- 性能优化：验证后切换到双采样双更新（RCR=0）


## 转子初始定位(寻相)

### 12脉冲与二分法初始位置检测流程

**核心原理**: 通过电压脉冲矢量与转子磁极轴线对齐时电感最小、电流响应最大的特性，结合磁编码器反馈，实现转子位置的精确检测。

#### 1. 第一阶段：12脉冲法粗定位（30°精度）

**目标**: 将360°电角度划分为12个30°扇区，确定转子所在扇区。

**流程**:
- 施加12个间隔30°的电压矢量脉冲（0°, 30°, 60°, ..., 330°）
- 每个脉冲测量三相电流并计算电流矢量幅值 I_mag = √(Iα² + Iβ²)
- 最大I_mag对应的脉冲角度即为转子d轴方向
- 确定30°扇区范围（如脉冲2对应60°，则扇区为[45°, 75°]）

#### 2. 第二阶段：二分法精定位（<1°精度）

**目标**: 在30°扇区内迭代逼近，获得精确转子位置。

**迭代流程**:
1. 设置搜索区间 [θ_low, θ_high] = 粗定位扇区
2. 计算测试角度 θ_test = (θ_low + θ_high) / 2
3. 施加θ_test方向的d轴电压脉冲
4. 观察磁编码器角度变化：
   - θ_enc减小 → 转子逆时针运动 → θ_real < θ_test → θ_high = θ_test
   - θ_enc增大 → 转子顺时针运动 → θ_real > θ_test → θ_low = θ_test
5. 重复步骤2-4，直到区间宽度 < 1°
6. 输出最终角度 θ_final = (θ_low + θ_high) / 2

**示例**: 真实位置50°，粗定位[45°,75°]
- 迭代1: θ_test=60° → CCW运动 → 区间[45°,60°]
- 迭代2: θ_test=52.5° → CCW运动 → 区间[45°,52.5°]  
- 迭代3: θ_test=48.75° → CW运动 → 区间[48.75°,52.5°]
- 继续迭代至精度要求

#### 3. 注意事项
- 严格控制脉冲参数防止过流
- 确保电机轴静止不受外力
- 考虑采样和控制延迟
- 最终验证q轴电流极性







## 控制环路执行频率
### 单中断多信号量
参考，未实现

```c
// 信号量定义
osSemaphoreId_t speed_loop_sem;    // 速度环信号量 - 1kHz
osSemaphoreId_t position_loop_sem; // 位置环信号量 - 500Hz
osSemaphoreId_t diag_loop_sem;     // 诊断环信号量 - 100Hz

// 频率配置
#define CURRENT_LOOP_FREQ     20000   // 20kHz电流环
#define SPEED_LOOP_FREQ       1000    // 1kHz速度环
#define POSITION_LOOP_FREQ    500     // 500Hz位置环  
#define DIAG_LOOP_FREQ        100     // 100Hz诊断环

// 分频系数计算
#define SPEED_DIVIDER         (CURRENT_LOOP_FREQ / SPEED_LOOP_FREQ)      // 20
#define POSITION_DIVIDER      (CURRENT_LOOP_FREQ / POSITION_LOOP_FREQ)   // 40
#define DIAG_DIVIDER          (CURRENT_LOOP_FREQ / DIAG_LOOP_FREQ)       // 200

// 电流环中断 - 统一计数器分发
void TIM1_UP_TIM10_IRQHandler(void)
{
    if (TIM1->SR & TIM_SR_UIF) {
        TIM1->SR &= ~TIM_SR_UIF;
        
        static uint32_t current_loop_count = 0;
        current_loop_count++;
        
        // 执行电流环
        FOC_CurrentLoop();
        
        // 按不同频率释放信号量
        if (current_loop_count % SPEED_DIVIDER == 0) {
            osSemaphoreRelease(speed_loop_sem);      // 1kHz
        }
        
        if (current_loop_count % POSITION_DIVIDER == 0) {
            osSemaphoreRelease(position_loop_sem);   // 500Hz
        }
        
        if (current_loop_count % DIAG_DIVIDER == 0) {
            osSemaphoreRelease(diag_loop_sem);       // 100Hz
            current_loop_count = 0;  // 复位计数器
        }
    }
}