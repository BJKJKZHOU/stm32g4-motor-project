

## 转子初始定位(寻相)

### 12脉冲与二分法初始位置检测流程

**核心原理**: 通过电压脉冲矢量与转子磁极轴线对齐时电感最小、电流响应最大的特性，结合磁编码器反馈，实现转子位置的精确检测。

#### 1. 第一阶段：12脉冲法粗定位（30°精度）

**目标**: 将360°电角度划分为12个30°扇区，确定转子所在扇区。

**流程**:
- 施加12个间隔30°的电压矢量脉冲（0°, 30°, 60°, ..., 330°）
- 每个脉冲测量三相电流并计算电流矢量幅值 I_mag = √(Iα² + Iβ²)
- 最大I_mag对应的脉冲角度即为转子d轴方向
- 确定30°扇区范围（如脉冲2对应60°，则扇区为[45°, 75°]）

#### 2. 第二阶段：二分法精定位（<1°精度）

**目标**: 在30°扇区内迭代逼近，获得精确转子位置。

**迭代流程**:
1. 设置搜索区间 [θ_low, θ_high] = 粗定位扇区
2. 计算测试角度 θ_test = (θ_low + θ_high) / 2
3. 施加θ_test方向的d轴电压脉冲
4. 观察磁编码器角度变化：
   - θ_enc减小 → 转子逆时针运动 → θ_real < θ_test → θ_high = θ_test
   - θ_enc增大 → 转子顺时针运动 → θ_real > θ_test → θ_low = θ_test
5. 重复步骤2-4，直到区间宽度 < 1°
6. 输出最终角度 θ_final = (θ_low + θ_high) / 2

**示例**: 真实位置50°，粗定位[45°,75°]
- 迭代1: θ_test=60° → CCW运动 → 区间[45°,60°]
- 迭代2: θ_test=52.5° → CCW运动 → 区间[45°,52.5°]  
- 迭代3: θ_test=48.75° → CW运动 → 区间[48.75°,52.5°]
- 继续迭代至精度要求

#### 3. 注意事项
- 严格控制脉冲参数防止过流
- 确保电机轴静止不受外力
- 考虑采样和控制延迟
- 最终验证q轴电流极性







## 控制环路执行频率
### 单中断多信号量
参考，未实现

```c
// 信号量定义
osSemaphoreId_t speed_loop_sem;    // 速度环信号量 - 1kHz
osSemaphoreId_t position_loop_sem; // 位置环信号量 - 500Hz
osSemaphoreId_t diag_loop_sem;     // 诊断环信号量 - 100Hz

// 频率配置
#define CURRENT_LOOP_FREQ     20000   // 20kHz电流环
#define SPEED_LOOP_FREQ       1000    // 1kHz速度环
#define POSITION_LOOP_FREQ    500     // 500Hz位置环  
#define DIAG_LOOP_FREQ        100     // 100Hz诊断环

// 分频系数计算
#define SPEED_DIVIDER         (CURRENT_LOOP_FREQ / SPEED_LOOP_FREQ)      // 20
#define POSITION_DIVIDER      (CURRENT_LOOP_FREQ / POSITION_LOOP_FREQ)   // 40
#define DIAG_DIVIDER          (CURRENT_LOOP_FREQ / DIAG_LOOP_FREQ)       // 200

// 电流环中断 - 统一计数器分发
void TIM1_UP_TIM10_IRQHandler(void)
{
    if (TIM1->SR & TIM_SR_UIF) {
        TIM1->SR &= ~TIM_SR_UIF;
        
        static uint32_t current_loop_count = 0;
        current_loop_count++;
        
        // 执行电流环
        FOC_CurrentLoop();
        
        // 按不同频率释放信号量
        if (current_loop_count % SPEED_DIVIDER == 0) {
            osSemaphoreRelease(speed_loop_sem);      // 1kHz
        }
        
        if (current_loop_count % POSITION_DIVIDER == 0) {
            osSemaphoreRelease(position_loop_sem);   // 500Hz
        }
        
        if (current_loop_count % DIAG_DIVIDER == 0) {
            osSemaphoreRelease(diag_loop_sem);       // 100Hz
            current_loop_count = 0;  // 复位计数器
        }
    }
}
```