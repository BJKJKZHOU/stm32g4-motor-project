# FOC_math 测试机制说明

## 测试原理

**测试使用原代码进行计算。**

### 测试流程详解

```c
// 1. 调用原代码函数（真实执行）
Inverse_Park_Transform(1.0f, 0.0f, 0.0f, 1.0f, &U_alpha, &U_beta);

// 2. 验证计算结果是否符合数学期望
TEST_ASSERT_FLOAT_EQUAL(1.0f, U_alpha, 0.001f, "验证消息");
```

**执行过程**：
1. **调用原函数**：`Inverse_Park_Transform()` 函数会执行真实的数学计算
2. **矩阵运算**：内部执行 `U_alpha = U_d*cosθ - U_q*sinθ` 等计算
3. **结果验证**：使用测试宏验证计算结果是否正确

## 测试框架结构

### 核心组件

```c
// 测试统计
static int tests_run = 0;     // 总测试数
static int tests_passed = 0;  // 通过测试数
static int tests_failed = 0;  // 失败测试数

// 测试宏
#define TEST_ASSERT(condition, message)                    // 布尔断言
#define TEST_ASSERT_FLOAT_EQUAL(expected, actual, tolerance, message) // 浮点数断言
#define TEST_ASSERT_Q31_EQUAL(expected, actual, tolerance, message)   // Q31定点数断言
```

### 测试函数模板

```c
void test_function_name(void)
{
    printf("\n--- Test Description ---\n");
    
    // 1. 准备测试数据
    float input1 = 1.0f;
    float input2 = 0.0f;
    float output;
    
    // 2. 调用原代码函数
    Function_Under_Test(input1, input2, &output);
    
    // 3. 验证结果
    TEST_ASSERT_FLOAT_EQUAL(expected, output, 0.001f, "验证描述");
}
```

## 添加新测试用例的完整步骤

### 步骤1：声明测试函数

在文件顶部的声明区域添加：
```c
void test_your_new_test(void);
```

### 步骤2：实现测试函数

```c
void test_your_new_test(void)
{
    printf("\n--- Test Your New Test ---\n");
    
    // 测试数据
    float U_alpha, U_beta;
    
    // 调用被测试的函数
    Inverse_Park_Transform(/* 参数 */, &U_alpha, &U_beta);
    
    // 验证结果
    TEST_ASSERT_FLOAT_EQUAL(expected_value, U_alpha, 0.001f, "验证消息");
    TEST_ASSERT_FLOAT_EQUAL(expected_value, U_beta, 0.001f, "验证消息");
}
```

### 步骤3：在main()中调用测试

```c
int main(void)
{
    // 现有测试...
    test_inverse_park_transform_basic();
    test_inverse_park_transform_90_degrees();
    
    // 添加你的新测试
    test_your_new_test();
    
    // 统计结果...
    return (tests_failed == 0) ? 0 : 1;
}
```

## 实际示例：已添加的测试用例

### 1. 45度测试
```c
void test_inverse_park_transform_45_degrees(void)
{
    printf("\n--- Test Inverse Park Transform (45 degrees) ---\n");
    float U_alpha, U_beta;
    
    // sin(45°) = cos(45°) = 0.7071
    float sin_45 = 0.7071067811865476f;
    float cos_45 = 0.7071067811865476f;
    
    Inverse_Park_Transform(1.0f, 0.0f, sin_45, cos_45, &U_alpha, &U_beta);
    
    // 验证：U_alpha = U_beta = 0.7071
    TEST_ASSERT_FLOAT_EQUAL(0.7071f, U_alpha, 0.001f, "45度变换验证");
    TEST_ASSERT_FLOAT_EQUAL(0.7071f, U_beta, 0.001f, "45度变换验证");
}
```

### 2. 负电压测试
```c
void test_inverse_park_transform_negative_voltage(void)
{
    printf("\n--- Test Inverse Park Transform (Negative Voltage) ---\n");
    float U_alpha, U_beta;
    
    Inverse_Park_Transform(-1.0f, 0.0f, 0.0f, 1.0f, &U_alpha, &U_beta);
    
    // 验证负电压处理
    TEST_ASSERT_FLOAT_EQUAL(-1.0f, U_alpha, 0.001f, "负电压验证");
    TEST_ASSERT_FLOAT_EQUAL(0.0f, U_beta, 0.001f, "负电压验证");
}
```

### 3. 双分量测试
```c
void test_inverse_park_transform_both_components(void)
{
    printf("\n--- Test Inverse Park Transform (Both Components) ---\n");
    float U_alpha, U_beta;
    
    // U_d=1.0, U_q=1.0, theta=30°
    float sin_30 = 0.5f;
    float cos_30 = 0.8660254037844386f;
    
    Inverse_Park_Transform(1.0f, 1.0f, sin_30, cos_30, &U_alpha, &U_beta);
    
    // 验证复合输入的变换结果
    TEST_ASSERT_FLOAT_EQUAL(0.3660f, U_alpha, 0.001f, "双分量alpha验证");
    TEST_ASSERT_FLOAT_EQUAL(1.3660f, U_beta, 0.001f, "双分量beta验证");
}
```

## 测试运行结果

```
========================================
Test Results Summary:
Total Tests: 25
Passed: 25
Failed: 0
Success Rate: 100.0%
========================================
```

## 最佳实践

### 1. 测试设计原则
- **边界测试**：测试0值、最大值、最小值
- **特殊情况**：测试负数、异常输入
- **数学验证**：确保结果符合数学公式
- **实际场景**：模拟真实使用场景

### 2. 容差设置
```c
// 根据计算精度设置合理的容差
TEST_ASSERT_FLOAT_EQUAL(expected, actual, 0.001f, "高精度测试");  // 0.1%容差
TEST_ASSERT_FLOAT_EQUAL(expected, actual, 0.01f, "中等精度测试"); // 1%容差
```

### 3. 测试消息
```c
// 清晰的测试消息有助于调试
"U_alpha = 1.0 when U_d=1.0, U_q=0.0, theta=0"  // 描述输入和期望输出
```

### 4. 测试覆盖率
- 每个函数至少一个基本测试
- 重要算法多个角度测试
- 边界条件和异常情况测试
